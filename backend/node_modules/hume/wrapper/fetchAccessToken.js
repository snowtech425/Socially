"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchAccessToken = void 0;
const base64Encode_1 = require("./base64Encode");
const zod_1 = require("zod");
/**
 * Fetches a new access token from the Hume API using the provided API key and Secret key.
 *
 * @param args - The arguments for the request.
 * @returns Promise that resolves to the new access token or null.
 * @throws If the base64 encoding fails.
 * @example
 * ```typescript
 * async function getToken() {
 *   const accessToken = await fetchAccessToken({
 *     apiKey: 'test',
 *     secretKey: 'test',
 *   });
 *
 *   console.log(accessToken); // Outputs the access token
 * }
 * ```
 */
const fetchAccessToken = ({ apiKey, secretKey, host = "api.hume.ai", }) => __awaiter(void 0, void 0, void 0, function* () {
    const authString = `${apiKey}:${secretKey}`;
    const encoded = (0, base64Encode_1.base64Encode)(authString);
    const response = yield fetch(`https://${host}/oauth2-cc/token`, {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Authorization: `Basic ${encoded}`,
        },
        body: new URLSearchParams({
            grant_type: "client_credentials",
        }).toString(),
        cache: "no-cache",
    })
        .then((res) => {
        // if reading response as json fails, return empty object
        // this can happen when request returns XML due to server error
        return res
            .json()
            .then((d) => d)
            .catch(() => ({}));
    })
        .then((data) => {
        // extract access_token value from received object
        return zod_1.z
            .object({
            access_token: zod_1.z.string(),
        })
            .transform((data) => {
            return data.access_token;
        })
            .safeParse(data);
    })
        .catch(() => ({
        success: false,
    }));
    if (!response.success) {
        return null;
    }
    return response.data;
});
exports.fetchAccessToken = fetchAccessToken;
